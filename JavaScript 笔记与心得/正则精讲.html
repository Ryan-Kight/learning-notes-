<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<script type="text/javascript">
		// 正则表达式
		// 转义字符“\” \n 换行 \r 行结束符 \t tab键
		// 实现多行书写的办法 用\转义掉后面的空格

		// 正则表达式是一个规则对象
		// var reg = /abc/; 字符片段，从str中寻找是否含有此片段的内容。 reg.test(str)
		// 		  /abc/i 忽略大小写 
		// 		  /abc/g 全局寻找多次此片段
		// 		  /abc/m 多行寻找此片段
		// var reg = new RexExp("规则","i/g/m");
		// 		如果不加new的话 两种创建正则的方式指向同一个引用

		// var reg = /[0-9][A-z][ai]/;//这当中的【ai】是【a或i】的关系，只要买足其一就可以匹配出来了
		// var str = "dsie9j9i9a"
		// console.log(str.match(reg));
		// ^放在[]里面是非的意思 eg：[^b]就是除了b以外都可以的意思 []里面放两个东西，就算是或的意思了
		// |放在（）里面是或的意思 也可以直接放在/里面/ eg：（abc|bcd）可以是abc也可以是bcd

		// 元字符
		// /\w/ === [0-9 + A-z + _]
		// /\W/ === [^\w]
		// /\d/ === [0-9]
		// /\D/ === [^\d]
		// /\s/ === [\t \n \r \v \f 诸如此类的空白类字符]
		// /\S/ === [^\s]
		// /\b/ === 单词边界，就是光标位置
		// /\B/ === 非单词边界
		// \t 和 \n 必须是被检测字符串中真实含有的东西

		// \u0000 十六进制的unicode码
		// 分为十六层空间 [\u0000 - \uffff]包含了一切字符 \s\S === everything
		// \u010000 --- \u01ffff
		// \u100000 --- \u10ffff

		// · === [^\r\n]除了换行符和行结束符的一切东西

		// []方括号中间的内容是针对于一位的规则



		// 量词			贪婪匹配原则
		// n+ 的范围为{1，（infinity 是不写的}
		// n* 的范围为{0，（infinity 是不写的}
		// n? 的范围为{0，1}
		// n{x} 的范围{3} 三个三个匹配
		// n{x,y} 的范围自定义 eg：{2,4} 因为贪婪法则 能多则多，能4不2
		// n{x,} 的范围从几开始到无穷
		// ...$ 以什么结尾的
		// ^... 以什么开头的
		// ^...$限定当中的字符，只有一模一样才能匹配出来

		// 检验一个字符串首尾是否含有数字
		// var reg = /^\d | \d$/;
		// 检验一个字符串首尾是否都含有数字
		// var reg = /^\d[\s\S]*\d$/

		// reg.sourse 展示内容

		// reg.exec(str)
		// reg.lastIndex 
		// 这两个东西可以理解为是绑定的，当找到内容后，游标会移到他的后面，下一次找的时候是以游标出现的位置进行查找

		// str.search(reg)用正则的规则去寻找内容，找到就返回匹配到的位置--光标位置，匹配不到就返回-1
		// str.split（） 以正则表达式拆分 但是有子表达式的话，还是会返回。就是会把子表达式里面的内容显示出来

		// var str = 'aa';
		// var reg = /a/g;
		// console.log(str.replace(reg,"b"));会把aa全部换成bb，因为g有访问字符串全局的能力

		// var str = "aabb";
		// var reg = /(\w)\1(\w)\2/;
		// console.log(str.replace(reg,"")); //$x能访问到子表达式中x的内容
		//什么是子表达式？ 就是用（）括起来的表达式，可以用\几的形式复制到，用$几到方式访问到

		// console.log(str.replace(reg,function($,$1,$2){
		// 	console.log(typeof($)); $内的东西是string类型的
		// 	return $+$1+$2; 可以直接返回$,也可以在后面拼接字符串。
		// }))

		//str.toUpperCase(),变成大写。 .toLowerCase(),变成小写
		//将the-first-name变成小驼峰式命名规则
		// var str = 'the-first-name';
		// var reg = /-(\w)/g;
		// console.log(str.replace(reg,function($,$1){
		// 	console.log($);		$当中包含的是所符合正则的所有值
		// 	return $1.toUpperCase();
		// }));

		//正向预查/正向断言
		//var reg = /a(?=b)/g;//找的是后面是b的a 就是本质上是找括号前的东西，但是括号后面跟的要是b才行
		// var reg = /\w(?!b)/g; //找的是后面不能是a的\w
		// var str = "23ba2b3aabaeb";
		// console.log(str.match(reg));

		// 如何打破贪婪匹配，能取少不取多
		// var reg = /a{1,3}?/; 在取位数的后面加上？就能打破贪婪匹配规则
		// var str = 'aaa';
		// console.log(str.match(reg));

		//要使 1000000 ---> 1,000,000
		// var str ="100100000";
		// var reg = /(?=(\B)(\d{3})+$)/g;
		// console.log(str.replace(reg,","));











	</script>
</body>
</html>